color(black).
color(white).
game(epaminondas).
gamecreator("Bob Abbott").
turn(1). %1 is white, 2 is black
horizontalLines(12).
verticalLines(14).

notturn(1,X):- X is 2.
notturn(2,X):- X is 1.

% 1 é branco, 2 é preto
estadoInicial( [ [2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1] ] ).

%Através de duast current window cláusulas recursivas imprimir o estado atual do jogo
sepforprint([],_,_,_).
sepforprint( [H|T], _totalVerticalLines, _totalHorizontalLines, _currentHorizontal):-
  write('     '),
  numbers(vert,_currentHorizontal),
  _currentHorizontal1 is _currentHorizontal - 1,
  printline(H),
  write('   |'),
  nl,
  write('     '),
  write('   '),
  write('  '),
  lineseparator(_totalVerticalLines),
  nl,
  sepforprint(T,_totalVerticalLines,_totalHorizontalLines,_currentHorizontal1).

numbers( horiz, _current):-
  _current < 15, _current >9,
  _current1 is _current + 1,
  write('   '),
  write(_current),
  write('   '),
  numbers(horiz, _current1).

numbers( horiz, _current):-
  _current < 10,
  _current1 is _current + 1,
  write('   '),
  write(' '),
  write(_current),
  write('   '),
  numbers(horiz, _current1).
numbers(horiz,_).

numbers( vert, _current):-
  _current >= 10,
  write(_current).

numbers( vert, _current):-
  _current < 10,
  write(' '),
  write(_current).

printline([]).
printline( [H|T] ):-
  write('   |   '),
  printchar(H),
  printline(T).

lineseparator(0).
lineseparator( N ):-
  N > 0,
  write(' -------'),
  N1 is N-1,
  lineseparator(N1).

%2 is Black 1 is White
printchar(0) :-
  write(' ').
printchar(1) :-
  write('W').
printchar(2) :-
  write('B').

%Simple boundary testing
size(X,Y):- X>=1, X=<14, Y>=1, Y=<12.

%Mostrar o tabuleiro inicial - only used for initial visual debugging
show :-
  estadoInicial(E),
  show(E).

%Recebe o tabuleiro e chama o separador
show(E):-
  nl,
  nl,
  write('     '),
  write('   '),
  write('  '),
  horizontalLines(_totalHorizontalLines),
  verticalLines(_totalVerticalLines),
  lineseparator(_totalVerticalLines),
  nl,
  sepforprint(E,_totalVerticalLines,_totalHorizontalLines,_totalHorizontalLines),
  nl,
  write('     '),
  write('   '),
  write('  '),
  numbers(horiz,1),!,1=1. % não meti ,!,fail. Porque iria dar no e isso podia confundir o utilizador.

% Its better to read the values (if there is a way) than create a rule with arguments. noob friendly
start :-
  estadoInicial(E),
  show(E),
  read(XS), read(YS), read(XD), read(YD), %le desta forma XS.YS.XD.YD.
  play(E, XS, YS, XD, YD).

play( E, XS, YS, XD, YD) :-
  xDIFy(XS,YS,XD,YD),
  size(XS,YS),
  size(XD,YD),
  atualizarEstado(E,XS,YS,XD,YD,N),
  show(N),
  read(XS), read(YS), read(XD), read(YD), % le desta forma XS.YS.XD.YD.
  play( N, XS, YS, XD, YD).
%If sizes are not allowed retry.
play(E,_,_,_,_):-badMoveFriend(E).

xDIFy(XS,YS,XD,YD) :-
  XS =\= XD; YS =\= YD.

atualizarEstado( E, XS, YS, XD, YD, N) :-
  XS1 is XS - 1,
  YS1 is 12 - YS, % Porque na verdade o que aparece no tabuleiro tem o índice trocado.
  canimovethere(E,XS,YS,XD,YD),
  mudarestado(E,XS,YS,XD,YD,N),
  turnchange(C).
atualizarEstado(E,_,_,_,_,_):-badMoveFriend(E).

%Rules for phalanx
canimovethere( E, XS, YS, XD, YD) :-
  regras( E, XS, YS, XD, YD).
%If rules are not respected
canimovethere( E, _, _, _, _):-badMoveFriend(E).

%Não é preciso fazer a distinção de regras entre phalanx e piece
%visto que uma piece é uma phalanx de tamanho 1
regras([H|T], XS, YS, XD, YD) :-
  turn(C),
  checkcolour(E,XS,YS,0,0,C),
  regra('sobreposicao',E,XD,YD),
  regra('capturar',E,XS,YS,XD,YD).

regra('sobreposicao', E, XD, YD) :-
  turn(X),
  notturn(X,NOTX),
  checkcolour(E,XD,YD,0,0,NOTX);
  checkcolour(E,XD,YD,0,0,0).

regra('capturar', E, XS, YS, XD, YD) :-
  Vert is YS - YD,
  Horizon is XS - XD,
  lineOfAction(Vert,Horizon,XS,YS,XD,YD).

lineOfAction(0, Horizon, E, XS, YS, XD, _) :-
  groupSizeMine(Horizon,E,XS,YS,N,_phalanxHead).

groupSizeMine(Horizon, E, XS, YS, _phalanxSize) :-
  getHead(YS,E,HEAD),
  turn(C),
  getSizeTilColour(HEAD,Horizon,XS,0,C,_phalanxSize).

%Não utilizamos a funcao charat pq em cada iteracao ele
%iria procurar a linha horizontal.
getSizeTilColour([H|T], Horizon, XS, N, C, _phalanxSize) :-
  Horizon > 0, H == C,
  XS1 is XS - 1,
  N1 is N + 1,
  getSizeTilColour(T,Horizon,XS1,N1,C,_).
getSizeTilColour(_,_,_,N,_,_phalanxSize):- _phalanxSize is N.
getSizeTilColour( [H|T], Horizon, XS, N, C, _phalanxSize) :-
  Horizon < 0, H == C,
  XS1 is XS + 1,
  N1 is N + 1,
  getSizeTilColour(T,Horizon,XS1,N1,C,_).
getSizeTilColour(_,_,_,N,_,_phalanxSize):- _phalanxSize is N.

%checkcolour:-estadoInicial(E),checkcolour(E,0,11,1).
checkcolour(E, XS, YS, C) :-
  charat(ELEMENT,XS,YS,E),
  !, % if TAIL == C fails then dont backtrack (checkcolour) go to atualizarEstado an then fail with badMoveFriend
  ELEMENT == C. % just checks if they are the same, == is different from =. Because = unifies and == doesnt.

%If a fact/rule fails we want player to have another go.
badMoveFriend(E):-
  nl,
  write('That move is not allowed.'),
  nl,
  show(E),
  read(XS), read(YS), read(XD), read(YD), % le desta forma XS.YS.XD.YD.
  play( E, XS, YS, XD, YD).

%mudar o conteúdo da lista de listas, necessário cláusula recursiva.
%checks if it is a phalanx or a piece. And acts upon that information.
%mudarestado( [H|T], XS, YS, XD, YD, N) :-

%changechar changes any cell of the board with the value passed in C(char)
%http://stackoverflow.com/questions/13103415/remove-element-x-y-from-list-of-lists-in-prolog (Source)

%changechar:- estadoInicial(E), changechar(1,0,0,E,N), show(N). Example

changechar(C,X,Y,[H|T],[H|R]):- Y>0, Y1 is Y-1, changechar(C,X,Y1,T,R).
changechar(C,X,0,[H|T],[H1|T]):- changechar(C,X,H,H1).
changechar(C,X,[H|T],[H|T1]):- X>0, X1 is X-1, changechar(C,X1,T,T1).
changechar(C,0,[H|T],[C|T]).

%charat char at a given position on board
%charat(C):- estadoInicial(E), charat(C,0,0,E).
charat(C,X,Y,[H|T]):- Y>0, Y1 is Y-1, charat(C,X,Y1,T).
charat(C,X,0,[H|T]):- charat(C,X,H).
charat(C,X,[H|T]):- X>0, X1 is X-1, charat(C,X,T).
charat(C,0,[C|T]).

%getHead returns the list in a given index
%getHead(H):- estadoInicial(E), getHead(0,E,H).
getHead(Y,[H|T],Head):- Y>0, Y1 is Y-1, getHead(Y1,T,Head).
getHead(0,[H|T],H).

%changestate changes the state of the board after a player makes his move
%changestate:- estadoInicial(E),changestate(E,0,1,0,5,E1),show(E1).
changestate(E,XS,YS,XD,YD,E1):- turn(T),changechar(0,XS,YS,E,E2),changechar(T,XD,YD,E2,E1).

turnchange(turn(C)) :-
  ( C = white -> retract(turn(1)) ; retract(turn(2))),
  ( C = black -> asserta(turn(1)) ; asserta(turn(2))).
