color(black).
color(white).
game(epaminondas).
gamecreator("Bob Abbott").
turn(white).

% 1 é branco, 2 é preto
estadoInicial( [ [2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1] ] ).

%Através de duast current window cláusulas recursivas imprimir o estado atual do jogo
sepforprint( [] ).
sepforprint( [H|T] ):-
  write('     '),
  printline(H),
  write('   |'),
  nl,
  write('        '),
  lineseparator(14),
  nl,
  !, sepforprint(T).
% O ! é para quando o sepforprint nao unificar com o sepforprint( [H|T] ), e unificar com a
% condição base não ir a procura de mais soluções ( lineseparator e printline ), ou seja fazer um redo
% ou mais corretamente backtracking. Assim corta a possibilidade de fazer redo.

printline([]).
printline( [H|T] ):-
  write('   |   '),
  printchar(H),
  printline(T).

lineseparator(0).
lineseparator( N ):-
  write(' -------'),
  N1 is N-1,
  lineseparator(N1).

printchar(0) :-
  write(' ').
printchar(1) :-
  write('W').
printchar(2) :-
  write('B').

size(X,Y):- X>=1, X=<14, Y>=1, Y=<12.

%Mostrar o tabuleiro inicial - only used for initial visual debugging
show :-
  estadoInicial(E),
  nl,
  nl,
  write('        '),
  lineseparator(14),
  nl,
  !,sepforprint(E).
%Recebe o tabuleiro e chama o separador
show(E):-
  nl,
  nl,
  write('        '),
  lineseparator(14),
  nl,
  !,sepforprint(E).

% Its better to read the values (if there is a way) than create a rule with arguments. noob friendly
start :-
  estadoInicial(E),
  show(E),
  %read somehow, and put values in XS, YS, XD, YD
  read(XS), read(YS), read(XD), read(YD), %le desta forma XS,YS,XD,YD
  play(E, XS, YS, XD, YD).

%play( E, XS, YS, XD, YD) :-

% Não é preciso testar a cor aqui porque
% para além de ser chato para o jogador é redondante.
% Quando fizer pop de um elemento na posição XS,YS posso
% verificar se a cor é válida. 1 ou 2.
play( E, XS, YS, XD, YD) :-
  size(XS,YS),
  size(XD,YD),
  atualizarEstado(E,XS,YS,XD,YD,N),
  show(N),
  %read somehow, and put values in XS, YS, XD, YD,
  read(XS), read(YS), read(XD), read(YD), % le desta forma XS.YS.XD.YD.
  play( N, XS, YS, XD, YD).

atualizarEstado( E, XS, YS, XD, YD, N) :-
  canimovethere(E,XS,YS,XD,YD),
  mudarestado(E,XS,YS,XD,YD,N),
  turnchange(C).

%dado XS,YS e XD,YD verificar se existe lá peça e a cor; e verificar se é possível efetuar a jogada.
%não muda o estado atual só verifica.
%vai ser necessário usar o | para extrair e o _ para ignorar, e uma cláusula recursiva.
%canimovethere( [H|T], XS,YS,XD,YD) :-

%mudar o conteúdo da lista de listas, necessário cláusula recursiva.
%mudarestado( [H|T], XS, YS, XD, YD, N) :-

turnchange(turn(C)) :-
  ( C = white -> retract(turn(white)) ; retract(turn(black))),
  ( C = black -> asserta(turn(white)) ; asserta(turn(black))).

