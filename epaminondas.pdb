color(black).
color(white).
game(epaminondas).
gamecreator("Bob Abbott").
turn(1). %1 is white, 2 is black
horizontalLines(12).
verticalLines(14).

notturn(1,X):- X is 2.
notturn(2,X):- X is 1.

% 1 é branco, 2 é preto
estadoInicial( [ [2,2,2,2,2,2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2,2,2,2,2,2,2],[0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1] ] ).

%Através de duast current window cláusulas recursivas imprimir o estado atual do jogo
sepforprint([],_,_,_).
sepforprint( [H|T], _totalVerticalLines, _totalHorizontalLines, _currentHorizontal):-
  write('     '),
  numbers(vert,_currentHorizontal),
  _currentHorizontal1 is _currentHorizontal - 1,
  printline(H),
  write('   |'),
  nl,
  write('     '),
  write('   '),
  write('  '),
  lineseparator(_totalVerticalLines),
  nl,
  sepforprint(T,_totalVerticalLines,_totalHorizontalLines,_currentHorizontal1).

numbers( horiz, _current):-
  _current < 15, _current >9,
  _current1 is _current + 1,
  write('   '),
  write(_current),
  write('   '),
  numbers(horiz, _current1).

numbers( horiz, _current):-
  _current < 10,
  _current1 is _current + 1,
  write('   '),
  write(' '),
  write(_current),
  write('   '),
  numbers(horiz, _current1).
numbers(horiz,_).

numbers( vert, _current):-
  _current >= 10,
  write(_current).

numbers( vert, _current):-
  _current < 10,
  write(' '),
  write(_current).

printline([]).
printline( [H|T] ):-
  write('   |   '),
  printchar(H),
  printline(T).

lineseparator(0).
lineseparator( N ):-
  N > 0,
  write(' -------'),
  N1 is N-1,
  lineseparator(N1).

%2 is Black 1 is White
printchar(0) :-
  write(' ').
printchar(1) :-
  write('W').
printchar(2) :-
  write('B').

%Simple boundary testing
size(X,Y):- X>=1, X=<14, Y>=1, Y=<12.

%Mostrar o tabuleiro inicial - only used for initial visual debugging
show :-
  estadoInicial(E),
  show(E).

%Recebe o tabuleiro e chama o separador
show(E):-
  nl,
  nl,
  write('     '),
  write('   '),
  write('  '),
  horizontalLines(_totalHorizontalLines),
  verticalLines(_totalVerticalLines),
  lineseparator(_totalVerticalLines),
  nl,
  sepforprint(E,_totalVerticalLines,_totalHorizontalLines,_totalHorizontalLines),
  nl,
  write('     '),
  write('   '),
  write('  '),
  numbers(horiz,1),!,1=1. % não meti ,!,fail. Porque iria dar no e isso podia confundir o utilizador.

% Its better to read the values (if there is a way) than create a rule with arguments. noob friendly
start :-
  estadoInicial(E),
  show(E),
  read(XS), read(YS), read(XD), read(YD), %le desta forma XS.YS.XD.YD.
  play(E, XS, YS, XD, YD).

play( E, XS, YS, XD, YD) :-
  xDIFy(XS,YS,XD,YD),
  size(XS,YS),
  size(XD,YD),
  atualizarEstado(E,XS,YS,XD,YD,N),
  show(N),
  read(XS), read(YS), read(XD), read(YD), % le desta forma XS.YS.XD.YD.
  play( N, XS, YS, XD, YD).
%If sizes are not allowed retry.
play(E,_,_,_,_):-badMoveFriend(E).

xDIFy(XS,YS,XD,YD) :-
  XS =\= XD; YS =\= YD.

atualizarEstado( E, XS, YS, XD, YD, N) :-
  XS1 is XS - 1,
  YS1 is 12 - YS, % Porque na verdade o que aparece no tabuleiro tem o índice trocado.
  XD1 is XD - 1,
  YD1 is 12 - YD1,
  canimovethere(E,XS1,YS1,XD1,YD1),
  mudarestado(E,XS1,YS1,XD1,YD1,N),
  turnchange(C).
atualizarEstado(E,_,_,_,_,_):-badMoveFriend(E).

%Rules for phalanx
canimovethere( E, XS, YS, XD, YD) :-
  regras( E, XS, YS, XD, YD).
%If rules are not respected
canimovethere(E,_,_,_,_):-badMoveFriend(E).

%Não é preciso fazer a distinção de regras entre phalanx e piece
%visto que uma piece é uma phalanx de tamanho 1
regras([H|T], XS, YS, XD, YD) :-
  turn(C),
  checkcolour(E,XS,YS,C),
  regra('sobreposicao',E,XS,YS,XD,YD),
  regra('capturar',E,XS,YS,XD,YD).

regra('sobreposicao', E, XS, YS, XD, YD) :-
  charat(C1,XS,YS,E),
  charat(C2,XD,YD,E),
  C1 =\= C2.

regra('moverPhalanx', E, XS, YS, XD, YD) :-
   VerticalDifference is YD - YS,
   HorizontalDifference is XD - XS,
   lineOfAction(VertDifference,HorizontalDifference,E,XS,YS,XD,YD).

%lineOfActionHL :- changecharHL(E), lineOfAction(0,2,E,0,5,10,_), !, 1==1.
%lineOfActionHL :- changecharHL(E), lineOfAction(0,2,E,0,5,6,_), !, 1==1.
%changecharHL(F):- estadoInicial(E), changechar(1,0,5,E,N), changechar(1,1,5,N,F), show(F).
%changecharHL(G):- estadoInicial(E), changechar(1,0,5,E,N), changechar(1,1,5,N,F), changechar(1,2,5,F,X),
%                changechar(2,7,5,X,H),changechar(1,4,5,H,Z),changechar(2,6,5,Z,P),
%                changechar(2,5,5,P,U),changechar(2,9,5,U,G),show(G).
%lineOfActionHR :- changecharHR(E), lineOfAction(0,-2,E,7,5,0,_), !, 1==1.
%changecharHR(G):- estadoInicial(E), changechar(2,0,5,E,N), changechar(0,1,5,N,F), changechar(2,2,5,F,X),
%                 changechar(1,3,5,X,H),changechar(1,5,5,H,Z),changechar(1,6,5,Z,P),
%                 changechar(1,7,5,P,U),changechar(1,8,5,U,G),show(G).

lineOfAction(0, HorizontalDifference, E, XS, YS, XD, _) :-
  turn(C),
  getSizeTilColour('horizontalLine',HorizontalDifference,_,E,C,XS,YS,PhalanxSizeMine),
  notturn(C,NOTC),
  headPhalanx('horizontalLine',HorizontalDifference,PhalanxSizeMine,XS,XH,XHplus),
  charat(CC,XHplus,YS,E),
  findEnemyHead('horizontalLine',HorizontalDifference,CC,XHplus,YS,XD,E,XN),
  %nl, write('PositionOfEnemyHead '), write(XN),
  !,evaluate('horizontalLine',XH,XN,XD,PhalanxSizeMine), %if evaluate fails dont backtrack
  getSizeTilColour('horizontalLine',HorizontalDifference,_,E,NOTC,XN,YS,PhalanxSizeAdversary),
  %nl,write('PhalanxSizeMine '),write(PhalanxSizeMine),nl,write('PhalanxSizeAdversary '),write(PhalanxSizeAdversary),
  !,PhalanxSizeAdversary < PhalanxSizeMine.

%lineOfActionVB :- changecharVB(E), lineOfAction(2,0,E,6,0,_,11), !, 1==1.
%changecharVB(G):- estadoInicial(E), changechar(1,6,0,E,N), changechar(1,6,1,N,F), changechar(1,6,2,F,X),
%                 changechar(1,6,3,X,H),changechar(0,6,4,H,Z),changechar(0,6,5,Z,P),
%                 changechar(1,6,6,P,U),changechar(2,6,7,U,G),show(G).

lineOfAction( VerticalDifference, 0, E, XS, YS, _, YD) :-
  turn(C),
  getSizeTilColour('verticalLine',_,VerticalDifference,E,C,XS,YS,PhalanxSizeMine),
  notturn(C,NOTC),
  headPhalanx('verticalLine',VerticalDifference,PhalanxSizeMine,YS,YH,YHplus),
  charat(CC,XS,YHplus,E),
  findEnemyHead('verticalLine',VerticalDifference,CC,XS,YHplus,YD,E,YN),
  %nl, write('PositionOfEnemyHead '), write(YN),
  !,evaluate('verticalLine',YH,YN,YD,PhalanxSizeMine), %if evaluate fails dont backtrack
  getSizeTilColour('verticalLine',_,VerticalDifference,E,NOTC,XS,YN,PhalanxSizeAdversary),
  %nl,write('PhalanxSizeMine '),write(PhalanxSizeMine),nl,write('PhalanxSizeAdversary '),write(PhalanxSizeAdversary),
  !,PhalanxSizeAdversary < PhalanxSizeMine.

lineOfActionDB :- changecharDB(E), lineOfAction(2,2,E,0,0,11,11), !, 1==1.
changecharDB(G):- estadoInicial(E), changechar(1,0,0,E,N), changechar(1,1,1,N,F), changechar(1,2,2,F,X),
                 changechar(1,3,3,X,H),changechar(0,5,5,H,Z),changechar(0,6,6,Z,P),
                 changechar(2,7,7,P,U),changechar(2,8,8,U,G),show(G).

lineOfAction( VerticalDifference, HorizontalDifference, E, XS, YS, XD, YD) :-
  nl,
  write('3'),
  nl,
  Slope is abs(VerticalDifference/HorizontalDifference),
  nl,write(Slope),nl,
  Slope == 1,
  turn(C),
  getSizeTilColour('diagonalLine',HorizontalDifference,VerticalDifference,E,C,XS,YS,PhalanxSizeMine),
  notturn(C,NOTC),
  headPhalanx('diagonalLine', HorizontalDifference, VerticalDifference, PhalanxSizeMine, XS, YS, XH, YH, XHplus, YHplus),
  charat(CC,XHplus,YHplus,E),
  findEnemyHead('diagonalLine', HorizontalDifference, VerticalDifference, CC, XHplus, YHplus, XD, YD, E, XN, YN),
  nl, write('PositionOfEnemyHead '), write(YN),
  !, evaluate( 'diagonalLine', XS, YS, XH, YH, XHplus, YHplus, XN, YN, XD, YD),
  getSizeTilColour('diagonalLine',HorizontalDifference,VerticalDifference,E,NOTC,XN,YN,PhalanxSizeAdversary),
  nl,write('PhalanxSizeMine '),write(PhalanxSizeMine),nl,write('PhalanxSizeAdversary '),write(PhalanxSizeAdversary),
  !,PhalanxSizeAdversary < PhalanxSizeMine.

evaluate( 'diagonalLine', XS, YS, XH, YH, XHplus, YHplus, -1, -1, XD, YD) :-
  vert2dh is (YD - YH)**2,
  hor2dh is (XD - XH)**2,
  vert2hs is (YHplus - YS)**2,
  hor2hs is (XHplus - XS)**2,
  DISTANCEdh is sqrt(vert2dh + hor2dh),
  DISTANCEhs is sqrt(vert2hs + hor2hs),
  DISTANCEdh =< DISTANCEhs.
evaluate( 'diagonalLine', XS, YS, XH, YH, XHplus, YHplus, -2, -2, XD, YD) :- fail.
evaluate( 'diagonalLine', XS, YS, XH, YH, XHplus, YHplus, XN, YN, XD, YD) :-
  XN =\= -1, YN =\= -1, XN =\= -2, YN =\= -2,
  vert2hs is (YHplus - YS)**2,
  hor2hs is (XHplus - XS)**2,
  DISTANCEhs is sqrt(vert2hs + hor2hs),
  vert2nh is (YN - YH)**2,
  hor2nh is (XN - XH)**2,
  DISTANCEnh is sqrt(vert2nh + hor2nh),
  DISTANCEnh =< DISTANCEhs.

evaluate( 'horizontalLine', XH, -1, XD, PhalanxSize) :- DISTANCE is abs(XH - XD), DISTANCE =< PhalanxSize.
evaluate( 'horizontalLine', XH, -2, XD, PhalanxSize) :- fail. % if there is setup like this wwwww_wbbb, wwwww cant eat bbb.
evaluate( 'horizontalLine', XH, XN, XD, PhalanxSize) :- XN =\= -1, XN =\= -2, DISTANCE is abs(XH - XN), DISTANCE =< PhalanxSize.

evaluate( 'verticalLine', YH, -1, YD, PhalanxSize) :- DISTANCE is abs(YH - YD), DISTANCE =< PhalanxSize.
evaluate( 'verticalLine', YH, -2, YD, PhalanxSize) :- fail.
evaluate( 'verticalLine', YH, YN, YD, PhalanxSize) :- YN =\= -1, YN =\= -2, DISTANCE is abs(YH - YN), DISTANCE =< PhalanxSize.

headPhalanx('horizontalLine', HorizontalDifference, PhalanxSize, XS, XH, XHplus) :-
  HorizontalDifference > 0,
  XHplus is XS + PhalanxSize,
  XH is XHplus - 1.
headPhalanx('horizontalLine', HorizontalDifference, PhalanxSize, XS, XH, XHminus) :-
  HorizontalDifference < 0,
  XHminus is XS - PhalanxSize,
  XH is XHminus + 1.
headPhalanx('verticalLine', VertDifference, PhalanxSize, YS, YH, YHplus) :-
  VertDifference > 0,
  YHplus is YS + PhalanxSize,
  YH is YHplus - 1.
headPhalanx('verticalLine', VertDifference, PhalanxSize, YS, YH, YHminus) :-
  VertDifference < 0,
  YHminus is YS - PhalanxSize,
  YH is YHminus + 1.
headPhalanx('diagonalLine', HorizontalDifference, VertDifference, PhalanxSize, XS, YS, XH, YH, XHplus, YHplus) :-
  HorizontalDifference > 0, VertDifference > 0,
  XHplus is XS + PhalanxSize,
  YHplus is YS + PhalanxSize,
  XH is XHplus - 1,
  YH is YHplus - 1.
headPhalanx('diagonalLine', HorizontalDifference, VertDifference, PhalanxSize, XS, YS, XH, YH, XHplus, YHplus) :-
  HorizontalDifference > 0, VertDifference < 0,
  XHplus is XS + PhalanxSize,
  YHplus is YS - PhalanxSize,
  XH is XHplus - 1,
  YH is YHplus + 1.
headPhalanx('diagonalLine', HorizontalDifference, VertDifference, PhalanxSize, XS, YS, XH, YH, XHplus, YHplus) :-
  HorizontalDifference < 0, VertDifference > 0,
  XHplus is XS - PhalanxSize,
  YHplus is YS + PhalanxSize,
  XH is XHplus + 1,
  YH is YHplus - 1.
headPhalanx('diagonalLine', HorizontalDifference, VertDifference, PhalanxSize, XS, YS, XH, YH, XHplus, YHplus) :-
  HorizontalDifference < 0, VertDifference < 0,
  XHplus is XS - PhalanxSize,
  YHplus is YS - PhalanxSize,
  XH is XHplus + 1,
  YH is YHplus + 1.

getSizeTilColour(PhalanxSize) :- estadoInicial(E), getSizeTilColour('verticalLine',_,-2,E,1,11,11,PhalanxSize).
getSizeTilColour('horizontalLine',HorizontalDifference,_,E,C,X,Y,PhalanxSize):-
  HorizontalDifference > 0, X =< 13,
  charat(C1,X,Y,E),
  C1 == C,
  X1 is X+1,
  getSizeTilColour('horizontalLine',HorizontalDifference,_,E,C,X1,Y,PhalanxSize1),
  PhalanxSize is PhalanxSize1+1.

getSizeTilColour('horizontalLine',HorizontalDifference,_,E,C,X,Y,PhalanxSize):-
  HorizontalDifference < 0 , X >= 0,
  charat(C1,X,Y,E),
  C1 == C,
  X1 is X-1,
  getSizeTilColour('horizontalLine',HorizontalDifference,_,E,C,X1,Y,PhalanxSize1),
  PhalanxSize is PhalanxSize1+1.

getSizeTilColour('verticalLine',_,VerticalDifference,E,C,X,Y,PhalanxSize):-
  VerticalDifference > 0, Y =< 11,
  charat(C1,X,Y,E),
  C1 == C,
  Y1 is Y+1,
  getSizeTilColour('verticalLine',_,VerticalDifference,E,C,X,Y1,PhalanxSize1),
  PhalanxSize is PhalanxSize1+1.

getSizeTilColour('verticalLine',_,VerticalDifference,E,C,X,Y,PhalanxSize):-
  VerticalDifference < 0, Y >= 0,
  charat(C1,X,Y,E),
  C1 == C,
  Y1 is Y-1,
  getSizeTilColour('verticalLine',_,VerticalDifference,E,C,X,Y1,PhalanxSize1),
  PhalanxSize is PhalanxSize1+1.

getSizeTilColour('diagonalLine',HorizontalDifference,VerticalDifference,E,C,X,Y,PhalanxSize):-
  HorizontalDifference > 0, VerticalDifference > 0, X =< 13, Y =< 11,
  charat(C1,X,Y,E),
  C1 == C,
  X1 is X+1,
  Y1 is Y+1,
  getSizeTilColour('diagonalLine',HorizontalDifference,VerticalDifference,E,C,X1,Y1,PhalanxSize1),
  PhalanxSize is PhalanxSize1+1.

getSizeTilColour('diagonalLine',HorizontalDifference,VerticalDifference,E,C,X,Y,PhalanxSize):-
  HorizontalDifference > 0, VerticalDifference < 0, X =< 13, Y >= 0,
  charat(C1,X,Y,E),
  C1 == C,
  X1 is X+1,
  Y1 is Y-1,
  getSizeTilColour('diagonalLine',HorizontalDifference,VerticalDifference,E,C,X1,Y1,PhalanxSize1),
  PhalanxSize is PhalanxSize1+1.

getSizeTilColour('diagonalLine',HorizontalDifference,VerticalDifference,E,C,X,Y,PhalanxSize):-
  HorizontalDifference < 0, VerticalDifference > 0, X >= 0, Y =< 11,
  charat(C1,X,Y,E),
  C1 == C,
  X1 is X-1,
  Y1 is Y+1,
  getSizeTilColour('diagonalLine',HorizontalDifference,VerticalDifference,E,C,X1,Y1,PhalanxSize1),
  PhalanxSize is PhalanxSize1+1.

getSizeTilColour('diagonalLine',HorizontalDifference,VerticalDifference,E,C,X,Y,PhalanxSize):-
  HorizontalDifference < 0, VerticalDifference < 0, X >= 0, Y >= 0,
  charat(C1,X,Y,E),
  C1 == C,
  X1 is X-1,
  Y1 is Y-1,
  getSizeTilColour('diagonalLine',HorizontalDifference,VerticalDifference,E,C,X1,Y1,PhalanxSize1),
  PhalanxSize is PhalanxSize1+1.

getSizeTilColour(_,_,_,_,_,14,_,0).
getSizeTilColour(_,_,_,_,_,-1,_,0).
getSizeTilColour(_,_,_,_,_,_,12,0).
getSizeTilColour(_,_,_,_,_,_,-1,0).

getSizeTilColour(_,_,_,E,C,X,Y,0):-
  charat(C1,X,Y,E),
  C =\= C1.

%getSizeTilColour( 'horizontalLine', LIST, HorizontalDifference, XS, N, C, PhalanxSize) :-
%  HorizontalDifference < 0, XS =< 13,
%  charat(COLOUR,XS,LIST),
%  COLOUR == C,
%  XS1 is XS + 1,
%  getSizeTilColour('horizontalLine',LIST,HorizontalDifference,XS1,N1,C,PhalanxSize).
% lineOfAction(0, HorizontalDifference, E, XS, YS, XD, _) :-
%   groupSizeMine('horizontalLine',HorizontalDifference,E,XS,YS,PhalanxSize).

% groupSizeMine('horizontalLine',HorizontalDifference, E, XS, YS, PhalanxSize) :-
%   getHead(YS,E,LIST), % Recebe aqui a cabeça LIST
%   turn(C), %Recebe a cor
%   getSizeTilColour('horizontalLine',LIST,HorizontalDifference,XS,0,C,PhalanxSize).

% getSizeTilColour('horizontalLine',_,_,_,N,_,PhalanxSize):- PhalanxSize is N.

% lineOfAction( VerticalDifference, 0, E, XS, YS, _, YD) :-
%   groupSizeMine('verticalLine',VerticalDifference,E,XS,YS,PhalanxSize).

% groupSizeMine( 'verticalLine', VerticalDifference, E, XS, YS, PhalanxSize) :-
%   turn(C),
%   getSizeTilColour('verticalLine',E,VerticalDifference,XS,YS,0,C,PhalanxSize).

%checkcolour:-estadoInicial(E),checkcolour(E,0,11,1).
checkcolour(E, XS, YS, C) :-
  charat(ELEMENT,XS,YS,E),
  !, % if TAIL == C fails then dont backtrack (checkcolour) go to atualizarEstado an then fail with badMoveFriend
  ELEMENT == C. % just checks if they are the same, == is different from =. Because = unifies and == doesnt.

%If a fact/rule fails we want player to have another go.
badMoveFriend(E):-
  nl,
  write('That move is not allowed.'),
  nl,
  show(E),
  read(XS), read(YS), read(XD), read(YD), % le desta forma XS.YS.XD.YD.
  play( E, XS, YS, XD, YD).

%mudar o conteúdo da lista de listas, necessário cláusula recursiva.
%checks if it is a phalanx or a piece. And acts upon that information.
%mudarestado( [H|T], XS, YS, XD, YD, N) :-

%changechar changes any cell of the board with the value passed in C(char)
%http://stackoverflow.com/questions/13103415/remove-element-x-y-from-list-of-lists-in-prolog (Source)

%changechar:- estadoInicial(E), changechar(1,10,1,E,N), show(N). %Example

changechar(C,X,Y,[H|T],[H|R]):- Y>0, Y1 is Y-1, changechar(C,X,Y1,T,R).
changechar(C,X,0,[H|T],[H1|T]):- changechar(C,X,H,H1).
changechar(C,X,[H|T],[H|T1]):- X>0, X1 is X-1, changechar(C,X1,T,T1).
changechar(C,0,[_|T],[C|T]).

%charat char at a given position on board
charat(C):- changecharH(E), charat(C,11,11,E).
charat(C,X,Y,[_|T]):- Y>0, Y1 is Y-1, charat(C,X,Y1,T).
charat(C,X,0,[H|_]):- charat(C,X,H).
charat(C,X,[_|T]):- X>0, X1 is X-1, charat(C,X1,T).
charat(C,0,[C|_]).

changechar:- estadoInicial(E), changechar(2,13,11,E,N), show(N). %Example

%findh(XN) :- estadoInicial(E), findEnemyHead('horizontalLine',1,1,11,11,13,E,XN), !, 1=1.

findEnemyHead('horizontalLine',HorizontalDifference,C,XH,YH,XD,E,XN) :-
  HorizontalDifference > 0, XH < XD,
  C == 0,
  XH1 is XH + 1,
  charat(C1,XH1,YH,E),
  findEnemyHead('horizontalLine',HorizontalDifference,C1,XH1,YH,XD,E,XN).

findEnemyHead('horizontalLine',HorizontalDifference,C,XH,YH,XD,E,XN) :-
  HorizontalDifference < 0, XH > XD,
  C == 0,
  XH1 is XH - 1,
  charat(C1,XH1,YH,E),
  findEnemyHead('horizontalLine',HorizontalDifference,C1,XH1,YH,XD,E,XN).

findEnemyHead('horizontalLine',_,C,_,_,_,_,XN) :- turn(X), C == X, XN is -2.
findEnemyHead('horizontalLine',_,C,XD,YH,XD,E,XN) :- charat(COLOUR,XD,YH,E), C =\= COLOUR, XN is -1.
findEnemyHead('horizontalLine',_,_,XH,_,_,_,XN) :- XN is XH.

findEnemyHead('verticalLine',VerticalDifference,C,XH,YH,YD,E,YN) :-
  VerticalDifference > 0, YH < YD,
  C == 0,
  YH1 is YH + 1,
  charat(C1,XH,YH1,E),
  findEnemyHead('verticalLine',VerticalDifference,C1,XH,YH1,YD,E,YN).

findEnemyHead('verticalLine',VerticalDifference,C,XH,YH,YD,E,YN) :-
  VerticalDifference < 0, YH > YD,
  C == 0,
  YH1 is YH - 1,
  charat(C1,XH,YH1,E),
  findEnemyHead('verticalLine',VerticalDifference,C1,XH,YH1,YD,E,YN).

findEnemyHead('verticalLine',_,C,_,_,_,_,YN) :- turn(X), C == X, YN is -2.
findEnemyHead('verticalLine',_,C,XH,YD,YD,E,YN) :- charat(COLOUR,XH,YD,E), C =\= COLOUR, YN is -1.
findEnemyHead('verticalLine',_,_,_,YH,_,_,YN) :- YN is YH.

findEnemyHead('diagonalLine', HorizontalDifference, VerticalDifference, CC, XHplus, YHplus, XD, YD, E, XN, YN) :-
  HorizontalDifference > 0, VerticalDifference > 0, XHplus < XD, YHplus < YD,
  C == 0,
  XH1 is XHplus + 1,
  YH1 is YHplus + 1,
  charat(C1,XH1,YH1,E),
  findEnemyHead('diagonalLine',HorizontalDifference,VerticalDifference,C1,XH1,YH1,XD,YD,E,XN,YN).

findEnemyHead('diagonalLine', HorizontalDifference, VerticalDifference, CC, XHplus, YHplus, XD, YD, E, XN, YN) :-
  HorizontalDifference > 0, VerticalDifference < 0, XHplus < XD, YHplus > YD,
  C == 0,
  XH1 is XHplus + 1,
  YH1 is YHplus - 1,
  charat(C1,XH1,YH1,E),
  findEnemyHead('diagonalLine',HorizontalDifference,VerticalDifference,C1,XH1,YH1,XD,YD,E,XN,YN).

findEnemyHead('diagonalLine', HorizontalDifference, VerticalDifference, CC, XHplus, YHplus, XD, YD, E, XN, YN) :-
  HorizontalDifference < 0, VerticalDifference > 0, XHplus > XD, YHplus < YD,
  C == 0,
  XH1 is XHplus - 1,
  YH1 is YHplus + 1,
  charat(C1,XH1,YH1,E),
  findEnemyHead('diagonalLine',HorizontalDifference,VerticalDifference,C1,XH1,YH1,XD,YD,E,XN,YN).

findEnemyHead('diagonalLine', HorizontalDifference, VerticalDifference, CC, XHplus, YHplus, XD, YD, E, XN, YN) :-
  HorizontalDifference < 0, VerticalDifference < 0, XHplus > XD, YHplus > YD,
  C == 0,
  XH1 is XHplus - 1,
  YH1 is YHplus - 1,
  charat(C1,XH1,YH1,E),
  findEnemyHead('diagonalLine',HorizontalDifference,VerticalDifference,C1,XH1,YH1,XD,YD,E,XN,YN).

findEnemyHead('diagonalLine',_,_,C,_,_,_,_,_,XN,YN) :- turn(X), C == X, XN is -2, YN is -2.
findEnemyHead('diagonalLine',_,_,C,XD,YD,XD,YD,E,XN,YN) :- charat(COLOUR,XD,YD,E), C =\= COLOUR, XN is -1, YN is -1.
findEnemyHead('diagonalLine',_,_,C,XH,YH,_,_,_,XN,YN) :- XN is XH, YN is XH.

% %getHead returns the list in a given index
% %getHead(H):- estadoInicial(E), getHead(0,E,H).
% getHead(Y,[H|T],Head):- Y>0, Y1 is Y-1, getHead(Y1,T,Head).
% getHead(0,[H|T],H).

% movePhalanxUP :- estadoInicial(E), movePhalanxUP(E,11,11,10,2,E1),show(E1).
movePhalanxUP(E,X,YS,YD,N,E1):-
  N>0, turn(T),
  YS1 is YS-1,
  YD1 is YD-1,
  N1 is N-1,
  movePhalanxUP(E,X,YS1,YD1,N1,E3),
  changechar(0,X,YS,E3,E2),
  changechar(T,X,YD,E2,E1).
movePhalanxUP(E,_,_,_,0,E).

% movePhalanxDOWN :- estadoInicial(E), movePhalanxDOWN(E,0,0,2,2,E1),show(E1).
movePhalanxDOWN(E,X,YS,YD,N,E1):-
  N>0, turn(T),
  YS1 is YS+1,
  YD1 is YD+1,
  N1 is N-1,
  movePhalanxDOWN(E,X,YS1,YD1,N1,E3),
  changechar(0,X,YS,E3,E2),
  changechar(T,X,YD,E2,E1).
movePhalanxDOWN(E,_,_,_,0,E).

% movePhalanxRIGHT :- estadoInicial(E), movePhalanxRIGHT(E,0,0,2,2,E1),show(E1).
movePhalanxRIGHT(E,XS,XD,Y,N,E1):-
  N>0, turn(T),
  XS1 is XS+1,
  XD1 is XD+1,
  N1 is N-1,
  movePhalanxRIGHT(E,XS1,XD1,Y,N1,E3),
  changechar(0,XS,Y,E3,E2),
  changechar(T,XD,Y,E2,E1).
movePhalanxRIGHT(E,_,_,_,0,E).

% movePhalanxLEFT :- estadoInicial(E), movePhalanxLEFT(E,0,0,2,2,E1),show(E1).
movePhalanxLEFT(E,XS,XD,Y,N,E1):-
  N>0, turn(T),
  XS1 is XS-1,
  XD1 is XD-1,
  N1 is N-1,
  movePhalanxLEFT(E,XS1,XD1,Y,N1,E3),
  changechar(0,XS,Y,E3,E2),
  changechar(T,XD,Y,E2,E1).
movePhalanxLEFT(E,_,_,_,0,E).

% movePhalanxUPLEFT :- estadoInicial(E), movePhalanxUPLEFT(E,11,11,10,10,2,E1),show(E1).
movePhalanxUPLEFT(E,XS,YS,XD,YD,N,E1):-
  N>0, turn(T),
  XS1 is XS-1,
  YS1 is YS-1,
  XD1 is XD-1,
  YD1 is YD-1,
  N1 is N-1,
  movePhalanxUPLEFT(E,XS1,YS1,XD1,YD1,N1,E3),
  changechar(0,XS,YS,E3,E2),
  changechar(T,XD,YD,E2,E1).
movePhalanxUPLEFT(E,_,_,_,_,0,E).

% movePhalanxUPRIGHT :- estadoInicial(E), movePhalanxUPRIGHT(E,11,11,12,10,2,E1),show(E1).
movePhalanxUPRIGHT(E,XS,YS,XD,YD,N,E1):-
  N>0, turn(T),
  XS1 is XS+1,
  YS1 is YS-1,
  XD1 is XD+1,
  YD1 is YD-1,
  N1 is N-1,
  movePhalanxUPRIGHT(E,XS1,YS1,XD1,YD1,N1,E3),
  changechar(0,XS,YS,E3,E2),
  changechar(T,XD,YD,E2,E1).
movePhalanxUPRIGHT(E,_,_,_,_,0,E).

% movePhalanxDOWNLEFT :- estadoInicial(E), movePhalanxDOWNLEFT(E,3,0,2,1,2,E1),show(E1).
movePhalanxDOWNLEFT(E,XS,YS,XD,YD,N,E1):-
  N>0, turn(T),
  XS1 is XS-1,
  YS1 is YS+1,
  XD1 is XD-1,
  YD1 is YD+1,
  N1 is N-1,
  movePhalanxDOWNLEFT(E,XS1,YS1,XD1,YD1,N1,E3),
  changechar(0,XS,YS,E3,E2),
  changechar(T,XD,YD,E2,E1).
movePhalanxDOWNLEFT(E,_,_,_,_,0,E).

% movePhalanxDOWNRIGHT :- estadoInicial(E), movePhalanxDOWNRIGHT(E,3,0,4,1,2,E1),show(E1).
movePhalanxDOWNRIGHT(E,XS,YS,XD,YD,N,E1):-
  N>0, turn(T),
  XS1 is XS+1,
  YS1 is YS+1,
  XD1 is XD+1,
  YD1 is YD+1,
  N1 is N-1,
  movePhalanxDOWNRIGHT(E,XS1,YS1,XD1,YD1,N1,E3),
  changechar(0,XS,YS,E3,E2),
  changechar(T,XD,YD,E2,E1).
movePhalanxDOWNRIGHT(E,_,_,_,_,0,E).

% mudarestado(E,XS1,YS1,XD1,YD1,N),getSizeTilColour('horizontalLine',HorizontalDifference,_,E,C,X,Y,PhalanxSize):-
% changeState :- estadoInicial(E), changeState(E,0,0,2,0,E1),show(E1).
changeState(E,XS,YS,XD,YD,E1):-
  YS == YD,
  XS < XD,
  turn(C),
  HorizontalDifference is XD-XS,
  getSizeTilColour('horizontalLine',HorizontalDifference,_,E,C,XS,YS,N),
  movePhalanxRIGHT(E,XS,XD,YS,N,E1).

changeState(E,XS,YS,XD,YD,E1):-
  YS == YD,
  XS > XD,
  turn(C),
  HorizontalDifference is XD-XS,
  getSizeTilColour('horizontalLine',HorizontalDifference,_,E,C,XS,YS,N),
  movePhalanxLEFT(E,XS,XD,YS,N,E1).

% changeState :- estadoInicial(E), changeState(E,0,0,0,2,E1),show(E1).
changeState(E,XS,YS,XD,YD,E1):-
  XS == XD,
  YS < YD,
  turn(C),
  VerticalDifference is YD-YS,
  getSizeTilColour('verticalLine',_,VerticalDifference,E,C,XS,YS,N),
  movePhalanxDOWN(E,XS,YS,YD,N,E1).

% changeState :- estadoInicial(E), changeState(E,0,11,0,10,E1),show(E1).
changeState(E,XS,YS,XD,YD,E1):-
  XS == XD,
  YS > YD,
  turn(C),
  VerticalDifference is YD-YS,
  getSizeTilColour('verticalLine',_,VerticalDifference,E,C,XS,YS,N),
  movePhalanxUP(E,XS,YS,YD,N,E1).

% changeState:- estadoInicial(E), changeState(E,11,11,10,10,E1), show(E1).
changeState(E,XS,YS,XD,YD,E1):-
  XS > XD,
  YS > YD,
  turn(C),
  HorizontalDifference is XD-XS,
  VerticalDifference is YD-YS,
  getSizeTilColour('diagonalLine',HorizontalDifference,VerticalDifference,E,C,XS,YS,N),
  movePhalanxUPLEFT(E,XS,YS,XD,YD,N,E1).

changeState(E,XS,YS,XD,YD,E1):-
  XS < XD,
  YS < YD,
  turn(C),
  HorizontalDifference is XD-XS,
  VerticalDifference is YD-YS,
  getSizeTilColour('diagonalLine',HorizontalDifference,VerticalDifference,E,C,XS,YS,N),
  movePhalanxDOWNRIGHT(E,XS,YS,XD,YD,N,E1).

changeState(E,XS,YS,XD,YD,E1):-
  XS > XD,
  YS < YD,
  turn(C),
  HorizontalDifference is XD-XS,
  VerticalDifference is YD-YS,
  getSizeTilColour('diagonalLine',HorizontalDifference,VerticalDifference,E,C,XS,YS,N),
  movePhalanxDOWNLEFT(E,XS,YS,XD,YD,N,E1).

changeState(E,XS,YS,XD,YD,E1):-
  XS < XD,
  YS > YD,
  turn(C),
  HorizontalDifference is XD-XS,
  VerticalDifference is YD-YS,
  getSizeTilColour('diagonalLine',HorizontalDifference,VerticalDifference,E,C,XS,YS,N),
  movePhalanxUPRIGHT(E,XS,YS,XD,YD,N,E1).

turnchange(turn(C)) :-
  ( C = white -> retract(turn(1)) ; retract(turn(2))),
  ( C = black -> asserta(turn(1)) ; asserta(turn(2))).
